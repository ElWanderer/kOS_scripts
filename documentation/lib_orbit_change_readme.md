## lib\_orbit\_change (orbit shape-changing library)

### Description

This library provides a function for changing the shape (periapsis, apoapsis and argument of periapsis) of an orbit. This may require one or two burns, and these are checked before executing that they will not consume too much delta-v. Burns will be plotted somewhat intelligently, in that encounters with other bodies are avoided, but otherwise they are somewhat dumb. This is because they use the `lib_orbit.ks` function `nodeAlterOrbit()`, which is not the most efficient way of doing things, but it is the easiest to calculate.

Note that this is one of two similar libraries:
* `lib_orbit_change.ks` contains code for changing the shape of an orbit - periapsis, apoapsis and argument of periapsis.
* `lib_orbit_match.ks` contains code for changing the orientation of an orbit - inclination and longitutde of the ascending node.

### Requirements

* `lib_orbit.ks`
* `lib_burn.ks`

### Function reference

#### `changeOrbit(execute, staging_allowed, delta-v_limit, universal_timestamp, apoapsis, periapsis, argument_of_periapsis)`

This function is only expected to be called from `doOrbitChange()`. It runs in two different modes based on the value of `execute`:
* `FALSE` - manoeuvre nodes are plotted to put the apoapsis and periapsis in the right places according to the input parameters. The delta-v required for these are totalled and checked against the input `delta-v_limit`. The function will then return `TRUE` or `FALSE depending on whether the nodes require more of less delta-v than the limit.
* `TRUE` - manoeuvre nodes are plotted and executed in turn to put the apoapsis and periapsis in the right places according to the input parameters. The function will then return `TRUE` or `FALSE` depending on whether the burns were successful or not.

The function begins by calculating the difference between the current orbital parameters and the input parameters. It will only create nodes if the difference in these values is above certain parameters:
* If the input `argument_of_periapsis` is greater than or equal to `0` and the difference between the input and current value is greater than `0.05` degrees, this will trigger two burns to rotate the orbit and put the apoapsis and periapsis to the right values.
* If the input `argument_of_periapsis` is less than `0` or within `0.05` degrees of the current value, then we may still need one or two burns:
  * If the difference between the input `apoapsis` and the orbit's current apoapsis is greater than `apoapsis/50`, it is considered to be different enough to require a burn to change the apoapsis.
  * If the difference between the input `periapsis` and the orbit's current periapsis is greater than `periapsis/50`, it is considered to be different enough to require a burn to change the periapsis.

The calculation of each new node uses `bufferTime()` to ensure that the node will not be too soon to give the craft time to align with it. 

##### Node 1

If the orbit does not need rotating, then we can change the apoapsis by burning at the periapsis. If the apoapsis does not need changing, this node will be skipped.

If the orbit needs rotating, then the new periapsis location is related to the current periapsis by the angle between the new and old values. As the periapsis has a true anomaly of `0` (by definition), the true anomaly where we want to burn to change the apoapsis (thereby putting the periapsis at the location of the burn) is simply that angle: `argument_of_periapsis - SHIP:ORBIT:ARGUMENTOFPERIAPSIS`.

If the orbit generated by plotting this manoeuvre node has an encounter with another sphere of influence, we advance the time of the node by one orbit and re-check. Potentially this could go into an infinite loop if the input `apoapsis` is greater than the altitude of the edge of the body's sphere of influence.

##### Node 2

If the orbit does not need rotating, this node will be plotted depending on whether the periapsis needs changing or not.

If the orbit needs rotating, the first node will have moved the periapsis, and so a second node is assumed to be required to set it to the input value.

Whether the first node was plotted or not, we can now change the periapsis by burning at the apoapsis. However, there is an exception to this where the input `apoapsis` is actually lower than our original periapsis. In this situation, the first node will have swapped the positions of the apoapsis and periapsis, so the second node should now occur at the periapsis instead of the apoapsis.

If the orbit generated by plotting this manoeuvre node has an encounter with another sphere of influence, we advance the time of the node by one orbit and re-check. Potentially this could go into an infinite loop if the input orbit parameters closely match that of another body.

#### `doOrbitChange(staging_allowed, delta-v_limit, apoapsis, periapsis, argument_of_periapsis)`

This is the 'public-facing' function. It will call `changeOrbit()` to plot a set of manoeuvre nodes to change the orbital parameters to those passed in. If this is successful and within the `delta-v_limit`, `changeOrbit()` will be called again, this time to execute the nodes.

If there is already a manoeuvre node on the flight-path when this function is called, it will be executed before doing anything else. This is to avoid recalculating the manoeuvre just because the player switched vessels.

`staging_allowed` is passed in to the calls to `execNode()`.

If not specified, the default value for `argument_of_periapsis` is `-1`. This will maintain the orbit's existing value.

Geoff Banks / ElWanderer
